# -*- coding: utf-8 -*-
"""scenario_manager.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ccaXU1_CgrpoWKu57Grb2ehmwvNkX_HG
"""

import pandas as pd
import numpy as np
import copy
# Import the engine we built in Phase 2
from tnuos_engine import calculate_portfolio_impact, determine_tcr_band

class ScenarioModeler:
    def __init__(self, df_baseline_sites):
        """
        Initializes with the baseline portfolio.
        """
        self.baseline_sites = copy.deepcopy(df_baseline_sites)
        self.current_scenario_sites = copy.deepcopy(df_baseline_sites)
        self.year = 2026 # Default focus year

    def reset_scenario(self):
        """
        Reverts current scenario back to baseline.
        """
        self.current_scenario_sites = copy.deepcopy(self.baseline_sites)

    def run_capacity_optimization(self, reduction_percentage=0.10):
        """
        Scenario 1: What if we reduce Agreed Capacity by X%?
        Target: Try to drop sites into a lower TCR Band.
        """
        print(f"--- Running Scenario: Reduce Capacity by {reduction_percentage*100}% ---")

        # Reduce capacity
        self.current_scenario_sites['agreed_capacity_kva'] = (
            self.current_scenario_sites['agreed_capacity_kva'] * (1 - reduction_percentage)
        )

        # Round to nearest integer (kVA is usually integer)
        self.current_scenario_sites['agreed_capacity_kva'] = (
            self.current_scenario_sites['agreed_capacity_kva'].round(0).astype(int)
        )

        return self._calculate_delta("Capacity Optimization")

    def run_demand_flexibility(self, flex_factor=0.20):
        """
        Scenario 2: Demand Flexibility
        This does not change the Fixed Residual Band (which is based on Agreed Capacity).
        It only reduces the 'Locational' charge by assuming we turn down equipment during peaks.

        We implement this by creating a 'simulated_peak_kw' column that is lower than capacity.
        """
        print(f"--- Running Scenario: Demand Flexibility ({flex_factor*100}% reduction at peak) ---")

        # Assumption: Without flex, Peak = Agreed Capacity (conservative).
        # With flex, Peak = Agreed Capacity * (1 - flex_factor)


        # Run Baseline to get Locational Cost
        df_base_res = calculate_portfolio_impact(self.baseline_sites, self.year)

        # Calculate Savings
        # Saving = Locational Cost * Flex Factor
        # (Only applies to HH sites)
        savings = df_base_res[df_base_res['meter_type'] == 'HH']['locational_cost_pound'] * flex_factor

        total_saving = savings.sum()
        return total_saving

    def identify_band_drop_opportunities(self):
        """
        Identifies sites that are within 10% of a lower band threshold.
        """
        print("--- Analyzing Band Drop Opportunities ---")

        opportunities = []

        # Define Thresholds (simplified from your breakdown)
        # (Voltage, Current_Band_Max, Target_Band)
        lv_thresholds = {
            'Band 4': 231, # If > 231, try to get to 231 (Band 3)
            'Band 3': 150, # If > 150, try to get to 150 (Band 2)
            'Band 2': 80   # If > 80, try to get to 80 (Band 1)
        }

        # Iterate through baseline sites
        df_res = calculate_portfolio_impact(self.baseline_sites, self.year)

        for index, row in df_res.iterrows():
            if row['voltage_level'] == 'LV' and row['meter_type'] == 'HH':
                cap = row['agreed_capacity_kva']
                current_band = row['tcr_band']

                # Check if we can drop a band
                if current_band in ['Band 4', 'Band 3', 'Band 2']:
                    target_cap = lv_thresholds[current_band]

                    # If we are within 15% of the threshold
                    if cap > target_cap and cap <= (target_cap * 1.15):
                        reduction_needed = cap - target_cap

                        opportunities.append({
                            'site_id': row['site_id'],
                            'current_band': current_band,
                            'current_kVA': cap,
                            'target_kVA': target_cap,
                            'reduction_kVA': reduction_needed,
                            'status': 'OPPORTUNITY'
                        })

        return pd.DataFrame(opportunities)

    def _calculate_delta(self, scenario_name):
        """
        Helper to run engine and compare totals.
        """
        df_base_res = calculate_portfolio_impact(self.baseline_sites, self.year)
        df_scen_res = calculate_portfolio_impact(self.current_scenario_sites, self.year)

        base_cost = df_base_res['total_tnuos_cost'].sum()
        scen_cost = df_scen_res['total_tnuos_cost'].sum()

        savings = base_cost - scen_cost

        return {
            'Scenario': scenario_name,
            'Baseline Cost': float(base_cost),
            'Scenario Cost': float(scen_cost),
            'Total Savings': float(savings),
            'Sites Dropped Band': int((df_base_res['tcr_band'] != df_scen_res['tcr_band']).sum())
        }

# Testing
if __name__ == "__main__":
    # Create Dummy Data that includes a "Borderline" site
    data = {
        'site_id': ['Site_Optimized', 'Site_Static'],
        'meter_type': ['HH', 'HH'],
        'voltage_level': ['LV', 'LV'],
        'dno_zone': [12, 12],
        'agreed_capacity_kva': [160, 500], # 160 is Band 3. 150 is Band 2 limit.
        'annual_consumption_kwh': [0, 0]
    }
    df = pd.DataFrame(data)

    modeler = ScenarioModeler(df)

    # 1. Test Capacity Reduction
    result = modeler.run_capacity_optimization(reduction_percentage=0.10)
    print(f"\nScenario Result: {result}")

    # 2. Find Specific Opportunities
    modeler.reset_scenario()
    opps = modeler.identify_band_drop_opportunities()
    print("\nBand Drop Opportunities:")
    print(opps)